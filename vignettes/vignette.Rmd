---
title: "tan: A differential analysis pipeline for ChIP-seq data."
author: |
        | Duy Nguyen and S&#252;nd&#252;z Kele&#351;
        | Department of Statistics, University of Wisconsin-Madison
output: 
    BiocStyle::html_document2
bibliography: biblio.bib    
biblio-style: plain
vignette: >
    %\VignetteIndexEntry{Vignette Title}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}  
---

<meta http-equiv="content-type" content="text/html;charset=utf-8" />

```{r style, echo = FALSE, results = 'asis'}

    library(BiocStyle)
    markdown(css.files = c('custom.css'))

```

```{r extraload, include = FALSE, echo = FALSE, eval = TRUE}
    library(tan)
    library(knitr)
    library(Segvis)
    library(GenomicRanges)
    opts_chunk$set(fig.align = "center")
    options( warn = -1 )

```    
# Overview

In this vignette, we present a brief overview of the [tan](https://github.com/duydnguyen/tan/) package. This package provides a framework for identifying differentially enriched (DE) regions from ChIP-seq data. In this vignette, we utilized the data from a ChIP-seq experiment investigating H3K27me3 to illustrate our pipeline. To load the required packages, we use:

```{r load,include=TRUE,echo=TRUE,eval=FALSE}

    library(tan)
    # library(tanExample)

```

For inputs, [tan](https://github.com/duydnguyen/tan/) takes a set of genomic regions (or peaks) and their aligned reads from ChIP-seq experements. Its goal is to predict the DE regions between two or multiple conditions. Specifically, the pipeline performs the following steps:

1.
2. 

# Inputs

## A set of pre-define regions for DE pipeline
For its first input, [tan](https://github.com/duydnguyen/tan/) takes a set of genemic regions in \code{BED} format as candidates to perform differential analysis. If such candidate regions are unavailable, we suggest using `r Biocpkg("mosaics")` to obtain these regions.

## Extracting read coverage data 
After a set of candidate regions is available, [tan](https://github.com/duydnguyen/tan/) also takes read coverages from these regions. Here, we illustrate a way of obtain these coverage data via [Segvis](https://github.com/duydnguyen/tan-coverage) package. [tan](https://github.com/duydnguyen/tan/) accepts bam file to generate read coverages. First, we load the required packages.

```{r loadSegvis_show, include = TRUE, echo = TRUE, eval = FALSE}
    library(Segvis)
    library(GenomicRanges)
    
```   

For demonstration, we used the H3K27me3's region of BZW2's gene body whose genomic coordinates are stored in BZW2.bed.

```{r extractBam, include=TRUE, echo=TRUE, eval=TRUE}
    #library(ggplot2, quietly = TRUE)
    files = list.files(system.file("extdata/H3K27me3",
        package = "tan"),full.names = TRUE)
    basename(files[c(1,3)])
  
```

We then set up the following parameters 


```{r Segvis_params, include=TRUE, echo=TRUE, eval=TRUE}
gnames <- "BZW2"
mc_cores <- 4
bed_content <- read.table(file = files[1], stringsAsFactors = FALSE)
gr <- GRanges(seqnames = bed_content[, 1],
              ranges = IRanges(bed_content[,2], bed_content[,3]), 
              strand = "*")
chromosomes <- c("chr7")
gr
```

Next, we constructed the **Segvis** object


```{r Segvis_step1_noshow, include=FALSE, echo=FALSE, eval=TRUE}
rep1.1_minus_ChIP <- buildSegvis(name = "rep1.1_minus_ChIP",
                       file = files[3],
                       maxBandwidth = 101, fragLen = 300, isPET = FALSE,
                       chr = chromosomes)
regions(rep1.1_minus_ChIP) <- gr
# Create segvis_block object
rep1.1_minus_ChIP <- loadReads(rep1.1_minus_ChIP, mc = mc_cores)
rep1.1_minus_ChIP <- matchReads(rep1.1_minus_ChIP, mc = mc_cores)
rep1.1_minus_ChIP <- getCoverage(rep1.1_minus_ChIP, mc = mc_cores)
rep1.1_minus_ChIP_block <- Segvis_block(rep1.1_minus_ChIP, bw = 1, mc = mc_cores)
normConst(rep1.1_minus_ChIP_block) <- 87626218
rep1.1_minus_ChIP_block <- normalize(rep1.1_minus_ChIP_block, base = 10^8)
block_list <- Segvis_block_list(rep1.1_minus_ChIP_block)

```

```{r Segvis_step1_show, include = TRUE, echo = TRUE, eval = FALSE}
rep1.1_minus_ChIP <- buildSegvis(name = "rep1.1_minus_ChIP",
                       file = files[3],
                       maxBandwidth = 101, fragLen = 300, isPET = FALSE,
                       chr = chromosomes)
regions(rep1.1_minus_ChIP) <- gr
# Create segvis_block object
rep1.1_minus_ChIP <- loadReads(rep1.1_minus_ChIP, mc = mc_cores)
rep1.1_minus_ChIP <- matchReads(rep1.1_minus_ChIP, mc = mc_cores)
rep1.1_minus_ChIP <- getCoverage(rep1.1_minus_ChIP, mc = mc_cores)
rep1.1_minus_ChIP_block <- Segvis_block(rep1.1_minus_ChIP, bw = 1, mc = mc_cores)
normConst(rep1.1_minus_ChIP_block) <- 87626218
rep1.1_minus_ChIP_block <- normalize(rep1.1_minus_ChIP_block, base = 10^8)
block_list <- Segvis_block_list(rep1.1_minus_ChIP_block)
```   
