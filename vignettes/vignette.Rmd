---
title: "tan: A differential analysis pipeline for ChIP-seq data."
author: |
        | Duy Nguyen and S&#252;nd&#252;z Kele&#351;
        | Department of Statistics, University of Wisconsin-Madison
output: 
    BiocStyle::html_document2
bibliography: biblio.bib    
biblio-style: plain
vignette: >
    %\VignetteIndexEntry{Vignette Title}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}  
---

<meta http-equiv="content-type" content="text/html;charset=utf-8" />

```{r style, echo = FALSE, results = 'asis'}

    library(BiocStyle)
    markdown(css.files = c('custom.css'))

```

```{r extraload, include = FALSE, echo = FALSE, eval = TRUE}
    library(tan)
    library(knitr)
    library(Segvis)
    library(GenomicRanges)
    library(data.table)
    opts_chunk$set(fig.align = "center")

```    
# Overview

In this vignette, we present a brief overview of the [tan](https://github.com/duydnguyen/tan/) package. This package provides a framework for identifying differentially enriched (DE) regions from ChIP-seq data. In this vignette, we utilized the data from a ChIP-seq experiment investigating H3K27me3 to illustrate our pipeline. To load the required packages, we use:

```{r load,include=TRUE,echo=TRUE,eval=FALSE}

    library(tan)
    # library(tanExample)

```

For inputs, [tan](https://github.com/duydnguyen/tan/) takes a set of genomic regions (or peaks) and their aligned reads from ChIP-seq experements. Its goal is to predict the DE regions between two or multiple conditions. Specifically, the pipeline performs the following steps:

1.
2. 

# Inputs

## A set of pre-define regions for DE pipeline
For its first input, [tan](https://github.com/duydnguyen/tan/) takes a set of genemic regions in \code{BED} format as candidates to perform differential analysis. If such candidate regions are unavailable, we suggest using `r Biocpkg("mosaics")` to obtain these regions.

## Extracting read coverage data 
After a set of candidate regions is available, [tan](https://github.com/duydnguyen/tan/) also takes read coverages from these regions. Here, we illustrate a way of obtain these coverage data via [Segvis](https://github.com/duydnguyen/tan-coverage) package. [tan](https://github.com/duydnguyen/tan/) accepts bam file to generate read coverages. First, we load the required packages.

```{r loadSegvis_show, include = TRUE, echo = TRUE, eval = FALSE}
    library(Segvis)
    library(GenomicRanges)
    library(data.table)
    
```   

For demonstration, we used the H3K27me3's region of BZW2's gene body whose genomic coordinates are stored in BZW2.bed.

```{r extractBam, include=TRUE, echo=TRUE, eval=TRUE}
    #library(ggplot2, quietly = TRUE)
    files = list.files(system.file("extdata/H3K27me3",
        package = "tan"),full.names = TRUE)
    basename(files[c(1,3)])
  
```

We then set up the following parameters 


```{r Segvis_params, include=TRUE, echo=TRUE, eval=TRUE}
gnames <- "BZW2"
mc_cores <- 4
bed_content <- read.table(file = files[1], stringsAsFactors = FALSE)
gr <- GRanges(seqnames = bed_content[, 1],
              ranges = IRanges(bed_content[,2], bed_content[,3]), 
              strand = "*")
chromosomes <- c("chr7")

```

Next, we constructed the **Segvis** object:


```{r Segvis_step1_noshow, include=FALSE, echo=FALSE, eval=TRUE}
rep1.1_minus_ChIP <- buildSegvis(name = "rep1.1_minus_ChIP",
                       file = files[3],
                       maxBandwidth = 101, fragLen = 300, isPET = FALSE,
                       chr = chromosomes)
regions(rep1.1_minus_ChIP) <- gr
# Create segvis_block object
rep1.1_minus_ChIP <- loadReads(rep1.1_minus_ChIP, mc = mc_cores)
rep1.1_minus_ChIP <- matchReads(rep1.1_minus_ChIP, mc = mc_cores)
rep1.1_minus_ChIP <- getCoverage(rep1.1_minus_ChIP, mc = mc_cores)
rep1.1_minus_ChIP_block <- Segvis_block(rep1.1_minus_ChIP, bw = 1, mc = mc_cores)
normConst(rep1.1_minus_ChIP_block) <- 87626218
rep1.1_minus_ChIP_block <- normalize(rep1.1_minus_ChIP_block, base = 10^8)
block_list <- Segvis_block_list(rep1.1_minus_ChIP_block)

```

```{r Segvis_step1_show, include = TRUE, echo = TRUE, eval = FALSE}
rep1.1_minus_ChIP <- buildSegvis(name = "rep1.1_minus_ChIP",
                       file = files[3],
                       maxBandwidth = 101, fragLen = 300, isPET = FALSE,
                       chr = chromosomes)
regions(rep1.1_minus_ChIP) <- gr
# Create segvis_block object
rep1.1_minus_ChIP <- loadReads(rep1.1_minus_ChIP, mc = mc_cores)
rep1.1_minus_ChIP <- matchReads(rep1.1_minus_ChIP, mc = mc_cores)
rep1.1_minus_ChIP <- getCoverage(rep1.1_minus_ChIP, mc = mc_cores)
rep1.1_minus_ChIP_block <- Segvis_block(rep1.1_minus_ChIP, bw = 1, mc = mc_cores)
normConst(rep1.1_minus_ChIP_block) <- 87626218
rep1.1_minus_ChIP_block <- normalize(rep1.1_minus_ChIP_block, base = 10^8)
block_list <- Segvis_block_list(rep1.1_minus_ChIP_block)
```   

To obtain the read coverage, we run the following code:

```{r Segvis_step2, include = TRUE, echo = TRUE, eval = TRUE}
rstart <- start(gr)[1]
rend <- end(gr)[1]
chr <- as.character(seqnames(gr)[1])
iden <- function(x) x

generate_coverage_foo <- function (object, condition, coord = NULL, mc, FUN, ...)
{
    .filter_sb <- function (object, cond)
    {
        if (any(is.na(cond))) {
            warning("There are regions impossible to evaluate")
            cond[is.na(cond)] = FALSE
        }
        V1 <- NULL
        coverage <- copy(cover_table(object))
        lengths <- coverage[, length(coord), by = list(chr, match)][,
            (V1)]
        extended_cond <- unlist(mapply(function(x, l) rep(x, l),
                                      cond, lengths, SIMPLIFY = FALSE))
        out_regions <- regions(object)[cond]
        rm(cond)
        coverage[, `:=`(cond, extended_cond)]
        coverage <- coverage[cond == TRUE]
        coverage[, `:=`(cond, NULL)]
        out <- new("segvis_block", name = name(object), regions = out_regions,
                  bandwidth = bandwidth(object), normConst = normConst(object),
                  cover_table = coverage, .isScaled = object@.isScaled)
        return(out)
    }
    create_plot_data <- function (counts, name, coord)
    {
        dt <- data.table(x = coord, y = counts, condition = name)
        return(dt)
    }
    .subset_logical <- function (object, condition_call)
    {
        cond <- as.logical(eval(condition_call, as(regions(object),
                                                  "data.frame"), parent.frame()))
        return(cond)
    }
    ### MAIN ###
    if (is.null(names(object))) {
        nms <- 1:length(object)
    }
    else {
        nms <- names(object)
    }
    if (!missing(condition)) {
        conds <- mclapply(object, .subset_logical, substitute(condition),
                          mc.cores = mc)
    }
    else {
        nregions <- lapply(object, function(x) length(regions(x)))
        conds <- lapply(nregions, function(x) rep(TRUE, x))
    }
    subsets <- mcmapply(.filter_sb, object, conds, SIMPLIFY = FALSE,
                        mc.cores = mc)
    widths <- mclapply(subsets, function(x) width(regions(x)),
                       mc.cores = mc)
    if (length(unique(unlist(widths))) > 1) {
        stop("The supplied regions doesn't have the same width")
    }
    else plot_width <- unique(unlist(widths))
    if (is.null(coord)) {
        coord <- 1:plot_width
    }
    profiles <- mclapply(subsets, summarize, FUN, ..., mc.cores = mc)
    plot_data <- mcmapply(create_plot_data, profiles, nms, MoreArgs = list(coord),
                          SIMPLIFY = FALSE, mc.silent = TRUE, mc.cores = mc, mc.preschedule = TRUE)
    # plot_data <- do.call(rbind, plot_data)

    dfCoverage <- data.frame(matrix(ncol = 0, nrow = dim(plot_data[[1]])[1] ))
    nSample <- length(plot_data)
    for (i in 1:nSample) {
        dfCoverage <- cbind(dfCoverage, plot_data[[i]][, y])
    }
    dfCoverage <- t(dfCoverage)
    rownames(dfCoverage) <- NULL
    return(dfCoverage)
}

coverage <- generate_coverage_foo(block_list, condition = seqnames == chr & start == rstart,
                           coord = rstart:rend, FUN = iden, mc = mc_cores)

# p <- tan::generate_coverage(object = block_list, condition = seqnames == chr & start == rstart,
#                           coord = rstart:rend, FUN = iden, mc = mc_cores)

dim(coverage)

```   
